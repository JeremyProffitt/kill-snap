name: Deploy Image Thumbnail Service

on:
  push:
    branches:
      - main
  workflow_dispatch:

env:
  AWS_REGION: ${{ vars.AWS_REGION }}

jobs:
  deploy:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.21'

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Install SAM CLI
        run: |
          pip install aws-sam-cli

      - name: Determine bucket name
        id: check-bucket
        run: |
          # Find existing image bucket with kill-snap in the name
          EXISTING_BUCKET=$(aws s3 ls | grep -o "kill-snap-images-[0-9]*" | head -1 || echo "")

          if [ -n "$EXISTING_BUCKET" ]; then
            echo "Found existing image bucket: ${EXISTING_BUCKET}"
            IMAGE_BUCKET="${EXISTING_BUCKET}"
          else
            # Use account ID for new bucket name
            ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
            IMAGE_BUCKET="kill-snap-images-${ACCOUNT_ID}"
            echo "Will use bucket name: ${IMAGE_BUCKET}"
          fi

          echo "bucket_name=${IMAGE_BUCKET}" >> $GITHUB_OUTPUT
          echo "Bucket name: ${IMAGE_BUCKET}"

      - name: Build SAM application
        run: |
          sam build

      - name: Create SAM deployment bucket if needed
        run: |
          BUCKET_NAME="sam-deploy-kill-snap-${AWS_REGION}"
          if ! aws s3 ls "s3://${BUCKET_NAME}" 2>&1 | grep -q 'NoSuchBucket'; then
            echo "Bucket ${BUCKET_NAME} already exists"
          else
            echo "Creating SAM deployment bucket: ${BUCKET_NAME}"
            aws s3 mb "s3://${BUCKET_NAME}" --region ${AWS_REGION} || true
          fi
        continue-on-error: true

      - name: Check and fix stuck CloudFormation stack and clean up buckets
        run: |
          BUCKET_NAME="${{ steps.check-bucket.outputs.bucket_name }}"
          WEBSITE_BUCKET="${BUCKET_NAME}-web"

          STACK_STATUS=$(aws cloudformation describe-stacks \
            --stack-name image-thumbnail-stack \
            --region ${AWS_REGION} \
            --query 'Stacks[0].StackStatus' \
            --output text 2>&1 || echo "DOES_NOT_EXIST")

          if [ "$STACK_STATUS" = "ROLLBACK_COMPLETE" ] || [ "$STACK_STATUS" = "REVIEW_IN_PROGRESS" ]; then
            echo "Stack is in $STACK_STATUS state, deleting..."
            aws cloudformation delete-stack \
              --stack-name image-thumbnail-stack \
              --region ${AWS_REGION}

            echo "Waiting for stack deletion..."
            aws cloudformation wait stack-delete-complete \
              --stack-name image-thumbnail-stack \
              --region ${AWS_REGION}

            echo "Stack deleted successfully"
            STACK_STATUS="DOES_NOT_EXIST"
          elif [ "$STACK_STATUS" = "DOES_NOT_EXIST" ]; then
            echo "Stack does not exist, proceeding with deployment"
          else
            echo "Stack status: $STACK_STATUS"
          fi

          # If stack doesn't exist, clean up any manually-created/retained resources
          if [ "$STACK_STATUS" = "DOES_NOT_EXIST" ]; then
            echo "Checking for manually-created or retained resources to clean up..."

            # Check and delete image bucket if it exists
            if aws s3 ls "s3://${BUCKET_NAME}" 2>&1 | grep -qv 'NoSuchBucket'; then
              echo "Found manually-created bucket: ${BUCKET_NAME}"
              echo "Emptying and deleting bucket so CloudFormation can manage it..."
              aws s3 rm "s3://${BUCKET_NAME}" --recursive || true
              aws s3api delete-bucket --bucket "${BUCKET_NAME}" --region ${AWS_REGION} || true
              echo "Deleted ${BUCKET_NAME}"
            else
              echo "Bucket ${BUCKET_NAME} does not exist"
            fi

            # Check and delete website bucket if it exists
            if aws s3 ls "s3://${WEBSITE_BUCKET}" 2>&1 | grep -qv 'NoSuchBucket'; then
              echo "Found manually-created bucket: ${WEBSITE_BUCKET}"
              echo "Emptying and deleting bucket so CloudFormation can manage it..."
              aws s3 rm "s3://${WEBSITE_BUCKET}" --recursive || true
              aws s3api delete-bucket --bucket "${WEBSITE_BUCKET}" --region ${AWS_REGION} || true
              echo "Deleted ${WEBSITE_BUCKET}"
            else
              echo "Bucket ${WEBSITE_BUCKET} does not exist"
            fi

            # Delete DynamoDB tables (they have Retain policy)
            TABLES_TO_DELETE=""
            for TABLE in kill-snap-ImageMetadata kill-snap-Users kill-snap-ReviewGroups; do
              if aws dynamodb describe-table --table-name ${TABLE} --region ${AWS_REGION} 2>&1 | grep -q "TableName"; then
                echo "Deleting retained DynamoDB table: ${TABLE}"
                aws dynamodb delete-table --table-name ${TABLE} --region ${AWS_REGION} || true
                TABLES_TO_DELETE="${TABLES_TO_DELETE} ${TABLE}"
              else
                echo "DynamoDB table ${TABLE} does not exist"
              fi
            done

            # Wait for DynamoDB tables to finish deleting
            for TABLE in ${TABLES_TO_DELETE}; do
              echo "Waiting for table ${TABLE} to finish deleting..."
              aws dynamodb wait table-not-exists --table-name ${TABLE} --region ${AWS_REGION} || true
              echo "Table ${TABLE} deleted"
            done

            # Delete Lambda functions if they exist
            for FUNC in ImageThumbnailGenerator ImageReviewApi; do
              if aws lambda get-function --function-name ${FUNC} --region ${AWS_REGION} 2>&1 | grep -q "FunctionName"; then
                echo "Deleting Lambda function: ${FUNC}"
                aws lambda delete-function --function-name ${FUNC} --region ${AWS_REGION} || true
              else
                echo "Lambda function ${FUNC} does not exist"
              fi
            done

            # Delete CloudWatch log groups (they persist after Lambda deletion)
            for FUNC in ImageThumbnailGenerator ImageReviewApi; do
              LOG_GROUP="/aws/lambda/${FUNC}"
              if aws logs describe-log-groups --log-group-name-prefix ${LOG_GROUP} --region ${AWS_REGION} 2>&1 | grep -q "logGroupName"; then
                echo "Deleting CloudWatch log group: ${LOG_GROUP}"
                aws logs delete-log-group --log-group-name ${LOG_GROUP} --region ${AWS_REGION} || true
              else
                echo "Log group ${LOG_GROUP} does not exist"
              fi
            done

            # Delete API Gateway REST APIs (if they exist with specific name patterns)
            API_NAME="image-thumbnail-stack"
            API_ID=$(aws apigateway get-rest-apis --region ${AWS_REGION} --query "items[?name=='${API_NAME}'].id" --output text 2>/dev/null || echo "")
            if [ -n "$API_ID" ]; then
              echo "Deleting API Gateway: ${API_NAME} (ID: ${API_ID})"
              aws apigateway delete-rest-api --rest-api-id ${API_ID} --region ${AWS_REGION} || true
            else
              echo "API Gateway ${API_NAME} does not exist"
            fi

            # Delete IAM roles created by SAM (they persist after stack deletion)
            echo "Cleaning up IAM roles created by SAM..."
            for ROLE in $(aws iam list-roles --query "Roles[?contains(RoleName, 'image-thumbnail-stack')].RoleName" --output text 2>/dev/null || echo ""); do
              if [ -n "$ROLE" ]; then
                echo "Deleting IAM role: ${ROLE}"
                # Detach managed policies first
                for POLICY_ARN in $(aws iam list-attached-role-policies --role-name ${ROLE} --query 'AttachedPolicies[].PolicyArn' --output text 2>/dev/null || echo ""); do
                  echo "  Detaching policy: ${POLICY_ARN}"
                  aws iam detach-role-policy --role-name ${ROLE} --policy-arn ${POLICY_ARN} 2>/dev/null || true
                done
                # Delete inline policies
                for POLICY_NAME in $(aws iam list-role-policies --role-name ${ROLE} --query 'PolicyNames[]' --output text 2>/dev/null || echo ""); do
                  echo "  Deleting inline policy: ${POLICY_NAME}"
                  aws iam delete-role-policy --role-name ${ROLE} --policy-name ${POLICY_NAME} 2>/dev/null || true
                done
                # Delete the role
                aws iam delete-role --role-name ${ROLE} 2>/dev/null || true
                echo "  Deleted role: ${ROLE}"
              fi
            done

            echo "Resource cleanup complete. CloudFormation will create them as managed resources."
            echo "Waiting 30 seconds for AWS to fully propagate deletions..."
            sleep 30
          fi
        continue-on-error: true

      - name: Package and inspect SAM template
        run: |
          # Package the template to see what's being generated
          sam package \
            --output-template-file .aws-sam/packaged-template.yaml \
            --s3-bucket sam-deploy-kill-snap-us-east-2 \
            --region ${AWS_REGION}

          echo "=== Generated CloudFormation Template ==="
          cat .aws-sam/packaged-template.yaml

      - name: Deploy SAM application
        id: deploy
        run: |
          # Only pass required parameters, CloudFront is disabled
          PARAMS="S3BucketName=${{ steps.check-bucket.outputs.bucket_name }} \
            AdminUsername=${{ vars.ADMIN_USER }} \
            AdminPassword=${{ secrets.ADMIN_PASSWORD }}"

          sam deploy \
            --template-file .aws-sam/packaged-template.yaml \
            --stack-name image-thumbnail-stack \
            --region ${AWS_REGION} \
            --capabilities CAPABILITY_IAM \
            --s3-bucket sam-deploy-kill-snap-us-east-2 \
            --parameter-overrides ${PARAMS} \
            --no-fail-on-empty-changeset
        continue-on-error: true

      - name: Debug deployment failure
        if: steps.deploy.outcome == 'failure'
        run: |
          echo "Deployment failed. Checking CloudFormation events..."
          aws cloudformation describe-stack-events \
            --stack-name image-thumbnail-stack \
            --region ${AWS_REGION} \
            --max-items 10 \
            --query 'StackEvents[?ResourceStatus==`CREATE_FAILED` || contains(ResourceStatusReason, `validation`) || contains(ResourceStatusReason, `ResourceExistenceCheck`)]' \
            --output json
          exit 1

      - name: Configure S3 event notification
        run: |
          # Get bucket name from CloudFormation outputs
          IMAGE_BUCKET=$(aws cloudformation describe-stacks \
            --stack-name image-thumbnail-stack \
            --query 'Stacks[0].Outputs[?OutputKey==`ImageBucketName`].OutputValue' \
            --output text)

          # Get Lambda ARN from stack outputs
          LAMBDA_ARN=$(aws cloudformation describe-stacks \
            --stack-name image-thumbnail-stack \
            --query 'Stacks[0].Outputs[?OutputKey==`ThumbnailLambdaArn`].OutputValue' \
            --output text)

          echo "Lambda ARN: ${LAMBDA_ARN}"
          echo "Configuring notifications for bucket: ${IMAGE_BUCKET}"

          # Add Lambda permission for S3 to invoke
          aws lambda add-permission \
            --function-name ImageThumbnailGenerator \
            --statement-id s3-trigger-permission \
            --action lambda:InvokeFunction \
            --principal s3.amazonaws.com \
            --source-arn arn:aws:s3:::${IMAGE_BUCKET} \
            || echo "Permission may already exist"

          # Configure S3 bucket notification
          cat > /tmp/notification.json <<EOF
          {
            "LambdaFunctionConfigurations": [{
              "LambdaFunctionArn": "${LAMBDA_ARN}",
              "Events": ["s3:ObjectCreated:*"],
              "Filter": {
                "Key": {
                  "FilterRules": [{
                    "Name": "suffix",
                    "Value": ".jpg"
                  }]
                }
              }
            }]
          }
          EOF

          aws s3api put-bucket-notification-configuration \
            --bucket ${IMAGE_BUCKET} \
            --notification-configuration file:///tmp/notification.json

      - name: Build and deploy web frontend
        run: |
          cd web
          npm install
          npm run build

          # Get website bucket name from CloudFormation outputs
          WEBSITE_BUCKET=$(aws cloudformation describe-stacks \
            --stack-name image-thumbnail-stack \
            --query 'Stacks[0].Outputs[?OutputKey==`WebsiteBucketName`].OutputValue' \
            --output text)

          echo "Deploying to website bucket: ${WEBSITE_BUCKET}"

          # Sync build folder to S3
          aws s3 sync build/ s3://${WEBSITE_BUCKET}/ --delete

          # Get CloudFront distribution ID and invalidate cache
          DISTRIBUTION_ID=$(aws cloudformation describe-stacks \
            --stack-name image-thumbnail-stack \
            --query 'Stacks[0].Outputs[?OutputKey==`CloudFrontDistributionId`].OutputValue' \
            --output text)

          if [ ! -z "$DISTRIBUTION_ID" ]; then
            echo "Invalidating CloudFront distribution: ${DISTRIBUTION_ID}"
            aws cloudfront create-invalidation \
              --distribution-id ${DISTRIBUTION_ID} \
              --paths "/*"
          fi

      - name: Initialize admin user
        run: |
          echo "Triggering API Lambda to initialize admin user..."

          # Invoke the Lambda function to trigger admin user creation
          aws lambda invoke \
            --function-name ImageReviewApi \
            --payload '{"httpMethod":"OPTIONS","path":"/api/login"}' \
            --cli-binary-format raw-in-base64-out \
            /tmp/lambda-response.json

          echo "Lambda invoked. Admin user should be created if it doesn't exist."
          cat /tmp/lambda-response.json

      - name: Output deployment info
        run: |
          echo "Deployment completed successfully"
          echo ""
          echo "=== CloudFormation Stack Outputs ==="
          aws cloudformation describe-stacks \
            --stack-name image-thumbnail-stack \
            --query 'Stacks[0].Outputs' \
            --output table
